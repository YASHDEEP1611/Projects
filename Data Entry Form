# Updated full code including date validation logic

import tkinter as tk
from tkinter import ttk, messagebox
from tkcalendar import DateEntry
from openpyxl import Workbook, load_workbook
from datetime import datetime
from dateutil.relativedelta import relativedelta
from PIL import Image, ImageTk
import os
import platform

FILENAME = "data_entry.xlsx"

remarks_options = ["Agreement Not Available", "Verify the Address", "No Documents in ZIP/File", "Verify the Installment Info", "Verify the Bank Details", "Incomplete Agreement", "No Remarks"]
type_options = ["1BR", "1BR+1CBR", "1BR+1CBR+1GR", "1BR+1GR", "1BR+2CBR", "1BR+2CBR+1GR"]
data_entry_by_options = ["UNKNOWN", "UNKNOWN", "UNKNOWN", "UNKNOWN", "UNKNOWN", "UNKNOWN",
                         "UNKNOWN", "UNKNOWN", "UNKNOWN"]
kyc_type_options = ["Aadhaar card", "PAN card", "Voter ID card", "Driver's license", "Passport", " "]
jurisdiction_options = ["Mumbai", "Kolkata", "Delhi", "Other"]
installment_options = ["Monthly", "Quarterly", "Half-Yearly", "Yearly"]
state_options = [
    "Andhra Pradesh", "Arunachal Pradesh", "Assam", "Bihar", "Chhattisgarh", "Goa", "Gujarat",
    "Haryana", "Himachal Pradesh", "Jharkhand", "Karnataka", "Kerala", "Madhya Pradesh",
    "Maharashtra", "Manipur", "Meghalaya", "Mizoram", "Nagaland", "Odisha", "Punjab",
    "Rajasthan", "Sikkim", "Tamil Nadu", "Telangana", "Tripura", "Uttar Pradesh",
    "Uttarakhand", "West Bengal", "Andaman & Nicobar Islands", "Chandigarh",
    "Dadra & Nagar Haveli", "Delhi", "Jammu and Kashmir", "Lakshadweep", "Puducherry", "Ladakh", ""
]

fields = {
    "Agreement Info": ["BARCODE", "TYPE", "AGMT NO", "AGMT DATE", "SPECIAL REMARK"],
    "BR Details": ["BR NAME", "BR FATHER", "BR FLAT", "BR STREET", "BR VILL", "BR POST",
                   "BR TALUKA", "BR DIST", "BR STATE", "BR PIN CODE"],
    "CBR Details": ["CBR NAME", "CBR FATHER", "CBR FLAT", "CBR STREET", "CBR VILL",
                    "CBR POST", "CBR TALUKA", "CBR DIST", "CBR STATE", "CBR PIN CODE"],
    "GR Details": ["GR NAME", "GR FATHER", "GR FLAT", "GR STREET", "GR VILL",
                   "GR POST", "GR TALUKA", "GR DIST", "GR STATE", "GR PIN CODE"],
    "Vehicle / Product Info": ["PRODUCT", "MODEL_MAKE", "REG NO", "ENGINE NO", "CHASSIS NO"],
    "Loan & Installment Info": ["NO OF INST", "INST AMT", "LOAN AMOUNT", "REPAY AMOUNT", 
                                "INSTALLMENT", "INST START DATE", "INST END DATE", "TOS W/O", "POS"],
    "Bank Details": ["BANK NAME", "BANK A/C NO", "BANK IFSC", "BANK ADDRESS", "BANK MICR"],
    "Attachment Details": ["KYC NUMBER", "KYC TYPE", "SALARY DETAILS", "REMARKS", "EMAIL"],
    "Case Details": ["ARB STATUS", "JURISDICTION", "CLAUSE NO", "CASE REMARKS", "DATA ENTRY BY"]
}

all_headers = sum(fields.values(), [])
entries = {}

if not os.path.exists(FILENAME):
    wb = Workbook()
    ws = wb.active
    ws.append(all_headers)
    wb.save(FILENAME)

def save_data():
    if not validate_dates():
        return

    data = [entries.get(key, tk.StringVar()).get() for key in all_headers]

    if not data[0] and not data[2]:
        messagebox.showerror("Error", "Enter BARCODE or AGMT NO before saving.")
        return

    try:
        wb = load_workbook(FILENAME)
        ws = wb.active
        updated = False

        for idx, row in enumerate(ws.iter_rows(min_row=2, values_only=True), start=2):
            if (data[0] and str(row[0]).strip().lower() == data[0].strip().lower()) or \
               (data[2] and str(row[2]).strip().lower() == data[2].strip().lower()):
                for col in range(1, len(all_headers)+1):
                    ws.cell(row=idx, column=col).value = data[col-1]
                updated = True
                break

        if not updated:
            ws.append(data)

        wb.save(FILENAME)

        messagebox.showinfo("Success", "Record updated successfully!" if updated else "Data saved successfully!")

        # ✅ CLEAR ALL FIELDS AFTER SAVING
        for var in entries.values():
            var.set("")

        # ✅ Set focus back to BARCODE field after clear
        root.after(100, lambda: entries["BARCODE"].set(""))

    except Exception as e:
        messagebox.showerror("Save Failed", f"An error occurred while saving:\n{e}")

def search_data():
    barcode = entries["BARCODE"].get().strip().lower()
    agreement = entries["AGMT NO"].get().strip().lower()
    wb = load_workbook(FILENAME)
    ws = wb.active
    for row in ws.iter_rows(min_row=2, values_only=True):
        if (barcode and str(row[0]).strip().lower() == barcode) or (agreement and str(row[2]).strip().lower() == agreement):
            for i, key in enumerate(all_headers):
                entries[key].set("" if row[i] is None else str(row[i]))
            messagebox.showinfo("Found", "Record loaded.")
            return
    messagebox.showwarning("Not Found", "No matching record found.")

def calculate_repayment(*args):
    try:
        inst = int(entries["NO OF INST"].get())
        inst_amt_expr = entries["INST AMT"].get().replace(" ", "")
        loan_amt_str = entries["LOAN AMOUNT"].get().replace(",", "").strip()

        # Skip calculation if loan amount is missing or not a valid number
        loan_amt = float(loan_amt_str) if loan_amt_str else 0.0

        # Evaluate or multiply to get repay amount
        if any(op in inst_amt_expr for op in ["*", "+", "-", "/"]):
            repay_amt = eval(inst_amt_expr, {"__builtins__": {}})
        else:
            repay_amt = float(inst_amt_expr) * inst

        # Compare repayment amount with loan amount
        if loan_amt and repay_amt < loan_amt:
            messagebox.showwarning("Warning", "Repayment amount should be greater than or equal to the Loan Amount.")
            entries["REPAY AMOUNT"].set("")
        else:
            entries["REPAY AMOUNT"].set(str(int(repay_amt)))

    except Exception as e:
        entries["REPAY AMOUNT"].set("")

def calculate_end_date(*args):
    try:
        freq = entries["INSTALLMENT"].get()
        start_date_str = entries["INST START DATE"].get()
        no_inst = int(entries["NO OF INST"].get())
        if not start_date_str or not freq or not no_inst:
            return
        start_date = datetime.strptime(start_date_str, "%d-%m-%Y")
        if freq == "Monthly":
            end_date = start_date + relativedelta(months=(no_inst - 1))
        elif freq == "Quarterly":
            end_date = start_date + relativedelta(months=(no_inst - 1) * 3)
        elif freq == "Half-Yearly":
            end_date = start_date + relativedelta(months=(no_inst - 1) * 6)
        elif freq == "Yearly":
            end_date = start_date + relativedelta(years=(no_inst - 1))
        else:
            end_date = start_date
        entries["INST END DATE"].set(end_date.strftime("%d-%m-%Y"))
    except:
        entries["INST END DATE"].set("")


import re

def validate_kyc(*args):
    kyc_number = entries["KYC NUMBER"].get().strip()
    kyc_type = entries["KYC TYPE"].get().strip()

    patterns = {
        "Aadhaar card": r"^\d{12}$",
        "PAN card": r"^[A-Z]{5}[0-9]{4}[A-Z]$",
        "Voter ID card": r"^[A-Z]{3}[0-9]{7}$",
        "Driver's license": r"^[A-Z]{2}\d{2}\d{11}$",
        "Passport": r"^[A-Z]{1}-?\d{7}$"
    }

    if kyc_type in patterns:
        pattern = patterns[kyc_type]
        if not re.fullmatch(pattern, kyc_number):
            messagebox.showerror("KYC Validation Failed", f"The entered {kyc_type} number is invalid.")
            entries["KYC NUMBER"].set("")


def force_kyc_uppercase(*args):
    current_value = entries["KYC NUMBER"].get()
    entries["KYC NUMBER"].set(current_value.upper())



def validate_dates(*args):
    try:
        agmt_date_str = entries["AGMT DATE"].get()
        inst_start_str = entries["INST START DATE"].get()
        inst_end_str = entries["INST END DATE"].get()
        freq = entries["INSTALLMENT"].get()
        no_inst = int(entries["NO OF INST"].get()) if entries["NO OF INST"].get().isdigit() else 0

        if agmt_date_str and inst_start_str:
            agmt_date = datetime.strptime(agmt_date_str, "%d-%m-%Y")
            inst_start = datetime.strptime(inst_start_str, "%d-%m-%Y")
            if inst_start < agmt_date:
                messagebox.showerror("Date Error", "Installment Start Date must be on or after Agreement Date.")
                entries["INST START DATE"].set("")
                return False

        if inst_start_str and inst_end_str:
            inst_start = datetime.strptime(inst_start_str, "%d-%m-%Y")
            inst_end = datetime.strptime(inst_end_str, "%d-%m-%Y")
            if inst_end < inst_start:
                messagebox.showerror("Date Error", "Installment End Date must be after Installment Start Date.")
                entries["INST END DATE"].set("")
                return False

        if inst_start_str and freq and no_inst:
            expected_end = inst_start
            if freq == "Monthly":
                expected_end += relativedelta(months=(no_inst - 1))
            elif freq == "Quarterly":
                expected_end += relativedelta(months=(no_inst - 1) * 3)
            elif freq == "Half-Yearly":
                expected_end += relativedelta(months=(no_inst - 1) * 6)
            elif freq == "Yearly":
                expected_end += relativedelta(years=(no_inst - 1))
            if inst_end_str:
                inst_end = datetime.strptime(inst_end_str, "%d-%m-%Y")
                if inst_end != expected_end:
                    messagebox.showerror("Date Error", f"Installment End Date should be {expected_end.strftime('%d-%m-%Y')}. Please correct it.")
                    return False
        return True
    except:
        return True

def exit_app():
    root.destroy()

def autocomplete(combobox):
    typed = combobox.get().lower()
    values = combobox.cget('values')
    matches = [v for v in values if v.lower().startswith(typed)]
    if matches:
        combobox.set(matches[0])
        combobox.icursor(len(typed))

def add_section(title, field_list, columns=5, dropdown_fields=None):
    frame = tk.LabelFrame(scroll_frame, text=title, font=("Arial", 10, "bold"))
    frame.pack(padx=10, pady=5, fill="x")
    for idx, field in enumerate(field_list):
        row = idx // columns
        col = (idx % columns) * 2
        tk.Label(frame, text=field, anchor="w", width=12).grid(row=row, column=col, padx=5, pady=2, sticky="w")
        var = tk.StringVar()
        if dropdown_fields and field in dropdown_fields:
            combo = ttk.Combobox(frame, textvariable=var, values=dropdown_fields[field], width=19, state="normal")
            combo.bind('<KeyRelease>', lambda e, cb=combo: autocomplete(cb))
            combo.grid(row=row, column=col+1, padx=5, pady=2)
        elif "DATE" in field.upper():
            date_widget = DateEntry(frame, textvariable=var, width=19, background='darkblue',
                                    foreground='white', date_pattern='dd-mm-yyyy')
            date_widget.grid(row=row, column=col+1, padx=5, pady=2)
        else:
            entry_widget = tk.Entry(frame, textvariable=var, width=22, undo=True)
            entry_widget.grid(row=row, column=col+1, padx=5, pady=2)

        entries[field] = var


root = tk.Tk()
root.title("Data Entry Form")
root.state("zoomed")

def undo_handler(event):
    widget = root.focus_get()
    if isinstance(widget, tk.Entry):
        widget.event_generate("<<Undo>>")

root.bind_all("<Control-z>", undo_handler)


canvas = tk.Canvas(root)
scrollbar = tk.Scrollbar(root, orient="vertical", command=canvas.yview)
scroll_frame = tk.Frame(canvas)
canvas.configure(yscrollcommand=scrollbar.set)
canvas.pack(side="left", fill="both", expand=True)
scrollbar.pack(side="right", fill="y")
canvas.create_window((0, 0), window=scroll_frame, anchor="nw")
scroll_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

os_name = platform.system()
def _on_mousewheel(event):
    if os_name == 'Windows':
        canvas.yview_scroll(-1 * int(event.delta / 120), "units")
    elif os_name == 'Darwin':
        canvas.yview_scroll(-1 * int(event.delta), "units")
    else:
        if event.num == 4:
            canvas.yview_scroll(-1, "units")
        elif event.num == 5:
            canvas.yview_scroll(1, "units")
canvas.bind_all("<MouseWheel>", _on_mousewheel)
canvas.bind_all("<Button-4>", _on_mousewheel)
canvas.bind_all("<Button-5>", _on_mousewheel)

header_buttons_frame = tk.Frame(scroll_frame)
header_buttons_frame.pack(pady=10, fill="x")
try:
    indialaw_img = Image.open("INDIALAW.png").resize((100, 50))
    indialaw_logo = ImageTk.PhotoImage(indialaw_img)
    tk.Label(header_buttons_frame, image=indialaw_logo).pack(side="left", padx=20)
except:
    pass

button_frame = tk.Frame(header_buttons_frame)
button_frame.pack(side="left", expand=True)
tk.Button(button_frame, text="SAVE", command=save_data, width=20, bg="lightgreen").grid(row=0, column=0, padx=5)
tk.Button(button_frame, text="SEARCH", command=search_data, width=20, bg="lightblue").grid(row=0, column=1, padx=5)
tk.Button(button_frame, text="EXIT", command=exit_app, width=20, bg="tomato").grid(row=0, column=2, padx=5)

try:
    legalese_img = Image.open("LEGALESE.png").resize((100, 50))
    legalese_logo = ImageTk.PhotoImage(legalese_img)
    tk.Label(header_buttons_frame, image=legalese_logo).pack(side="right", padx=20)
except:
    pass

add_section("Agreement Info", fields["Agreement Info"], dropdown_fields={"TYPE": type_options})
add_section("BR (Borrower) Details", fields["BR Details"], dropdown_fields={"BR STATE": state_options})
add_section("CBR (Co-Borrower) Details", fields["CBR Details"], dropdown_fields={"CBR STATE": state_options})
add_section("GR (Guarantor) Details", fields["GR Details"], dropdown_fields={"GR STATE": state_options})
add_section("Vehicle / Product Info", fields["Vehicle / Product Info"])
add_section("Loan & Installment Info", fields["Loan & Installment Info"], dropdown_fields={"INSTALLMENT": installment_options})
add_section("Bank Details", fields["Bank Details"])
add_section("Attachment Details", fields["Attachment Details"], dropdown_fields={"KYC TYPE": kyc_type_options, "REMARKS": remarks_options})
add_section("Case Details", fields["Case Details"], dropdown_fields={"JURISDICTION": jurisdiction_options, "DATA ENTRY BY": data_entry_by_options})

entries["LOAN AMOUNT"].trace("w", calculate_repayment)
entries["INST AMT"].trace("w", calculate_repayment)
entries["NO OF INST"].trace("w", lambda *args: [calculate_repayment(), calculate_end_date(), validate_dates()])
entries["INST START DATE"].trace("w", lambda *args: [calculate_end_date(), validate_dates()])
entries["INSTALLMENT"].trace("w", lambda *args: [calculate_end_date(), validate_dates()])
entries["AGMT DATE"].trace("w", validate_dates)
entries["INST END DATE"].trace("w", validate_dates)
entries["KYC NUMBER"].trace("w", validate_kyc)
entries["KYC TYPE"].trace("w", validate_kyc)
entries["KYC NUMBER"].trace("w", force_kyc_uppercase)

root.mainloop()
